# Стратегия

## Задача

1. Реализовать возможность "съедания" фруктов различными способами: проглотить целиком ("swallow"), откусывая по частям ("bite off") или предварительно разрезав на небольшие кусочки ("chop"). Возможно, перечень способов будет расширяться. **Изменять интерфейс существующих функций класса нельзя!** (потому что написано много кода, который использует существующий интерфейс)

2. Реализовать на семействе фруктов новую функцию запаха ``void Smell()`` - домашнее задание (?)

## Решение "в лоб" (без использования паттернов)

1. Объявить в интерфейсе фрукта функцию, которая задает "способ съедания" в виде нового перечисляемого типа ``enum class EatingMannerEnum``.
2. Дополнить свойства класса, добавив туда заданный "способ съедания": ``EatingMannerEnum EatingManner``
3. Единообразно переписать **в каждом подклассе** функцию ``void Eat()`` так, чтобы она использовала свойство EatingManner для определения того, что надо делать в процессе съедания фрукта.

## Решение с использованием паттерна "Стратегия"

1. Объявить перечисляемый тип способа съедания.
2. Создать класс абстрактный класс стратегии съедания ``EatingStrategy``
3. Унаследовать от него конкретные классы стратегий: ``SwallowEatingStrategy``, ``BiteOffEatingStrategy``, ``ChopEatingStrategy``
4. Разработать фабричный метод для создания экземпляров классов стратегий съедания.
5. Инкапсулировать стратегию съедания в родительском классе ``Fruit`` с использованием указателя.
6. Дополнить интерфейс класса ``Fruit`` функцией для задания стратегии ``SetEatingManner(EatingMannerEnum)``.
7. Переписать функцию ``Eat()`` родительского класса ``Fruit``, чтобы она использовала указанную стратегию.

## Краткая характеристика паттерна "Стратегия"

**Паттерн "Стратегия"** определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость. Он позволяет модифицировать алгоритмы независимо от их использования на стороне клиента.

# Шаблонный метод

## Задача

1. Унифицировать структуру алгоритма метода ``Eat()`` родительского класса ``Fruit`` и унаследованных от него классов.
2. Уменьшить количество дублируемого кода в методах ``Eat()``.

## Решение с использованием паттерна "Шаблонный метод"

1. Зафиксировать общую структуру алгоритма на уровне родительского класса, создав соответствующие абстрактные методы-этапы алгоритма. **Функция ``Eat()`` перестает быть виртуальной!**
2. Весь повторяющийся код реализовать на уровне родительского класса.
3. Весь специфический для конкретного фрукта код перенести в реализации методов-этапов на уровне унаследованных классов.

## Краткая характеристика паттерна "Шаблонный метод"

Паттерн "Шаблонный метод" задает "скелет" алгоритма в методе, оставляя определение реализации некоторых шагов унаследованным классам. Эти классы могут переопределять некоторые части алгоритма без изменения его структуры.